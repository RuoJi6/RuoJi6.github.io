[{"title":"Cobalt Strike主动识别方案","path":"/posts/58642.html","content":"最近在编写针对红队基础设施扫描的时候，研究针对红队C2识别一些方案特征，这里我们以Cobalt Strike作为特征举例。 0.1 思路众所周知，Cobalt Strike端口可以分为监听端口和Team Server连接端口。 监听端口：Cobalt Strike的Listeners。 连接端口：从客户端连接服务端的端口，由Team Server启动。 由于在攻防中，常见的Cobalt Strike监听端口是HTTP&#x2F;HTTPS，所有这里我们主要去研究HTTP/S和Team Server端口特征方法。 配置【Cobalt Strike 4.7】： 0.2 HTTP&#x2F;S 监听端口特征一 JARM【弱特征】JARM 是一种用于识别和分类 TLS（传输层安全）服务器的指纹识别工具。它通过向目标服务器发送特定构造的 TLS Client Hello 数据包，分析服务器返回的 Server Hello 响应，提取特定属性，生成独特的指纹。这些指纹可用于： 验证服务器组的 TLS 配置一致性：快速检查一组服务器是否具有相同的 TLS 配置。 服务器分组：根据 TLS 配置，将互联网上的服务器进行分组，例如，识别可能属于特定组织（如 Google、Salesforce、Apple）的服务器。 应用程序或基础设施识别：识别默认的应用程序或基础设施。 恶意服务器检测：识别互联网上的恶意软件命令和控制基础设施以及其他恶意服务器。 JARM 的工作原理包括： 发送特定的 TLS Client Hello 数据包：主动向目标 TLS 服务器发送 10 个特定构造的 Client Hello 数据包。 捕获服务器响应：记录服务器返回的 Server Hello 响应，提取其中的特定属性。 生成指纹：对收集的服务器响应进行处理，生成一个 62 字符的指纹，其中前 30 个字符表示服务器对每个 Client Hello 的密码套件和 TLS 版本选择，后 32 个字符是服务器发送的累积扩展名的截断 SHA256 哈希。 projectdiscovery&#x2F;tlsx: Fast and configurable TLS grabber focused on TLS based data collection. 特征：2ad2ad16d2ad2ad00042d42d00042ddb04deffa1705e2edc44cae1ed24a4da，但是由于可以自己生成SSL证书，所有JARM只能算是弱特征。 特征二 响应头【弱特征】默认访问 当我们使用OPTIONS去请求就会出现Allow: OPTIONS,GET,HEAD,POST。 特征：发送OPTIONS得到Allow: OPTIONS,GET,HEAD,POST。 特征三 checksum8算法【强特征】Cobalt Strike 中的 checksum8。在 Cobalt Strike 中，checksum8 是一种用于确定请求 URI 的算法。当用户向 Team Server 发送 HTTP 请求时，服务器会将请求的 URI 传递给 checksum8 函数，并将结果与整数值 92L 或 93L 进行比较。如果结果匹配，服务器将返回相应的 Beacon 二进制负载。具体而言，checksum8 用于区分 32 位和 64 位的 Beacon 负载。 以下是 checksum8函数的 Java 实现： 1234567891011public static long checksum8(String text) &#123; if (text.length() &lt; 4) &#123; return 0L; &#125; text = text.replace(&quot;/&quot;, &quot;&quot;); long sum = 0L; for (int x = 0; x &lt; text.length(); x++) &#123; sum += text.charAt(x); &#125; return sum % 256L;&#125; 也就是说checksum8实现之后的URL是固定的不是随机的，下面我们通过python代码实现这个算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import requestsimport stringfrom itertools import productimport warningswarnings.filterwarnings(&quot;ignore&quot;)def checksum8(uri): &quot;&quot;&quot; 计算 URI 的 checksum8 值。 &quot;&quot;&quot; if len(uri) &lt; 4: return 0 uri = uri.replace(&quot;/&quot;, &quot;&quot;) total = sum(ord(char) for char in uri) return total % 256def generate_uris(): &quot;&quot;&quot; 生成满足 checksum8 为 92（32 位）和 93（64 位）的 URI 列表。 &quot;&quot;&quot; chars = string.ascii_letters + string.digits for combo in product(chars, repeat=4): uri = &#x27;&#x27;.join(combo) cs8 = checksum8(uri) if cs8 == 92: yield uri, &#x27;32-bit&#x27; elif cs8 == 93: yield uri, &#x27;64-bit&#x27;def check_cs_server(base_url): &quot;&quot;&quot; 检查目标服务器是否为 Cobalt Strike 服务器。 &quot;&quot;&quot; headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36&#x27; &#125; for uri, arch in generate_uris(): url = f&quot;&#123;base_url&#125;/&#123;uri&#125;&quot; try: response = requests.get(url, headers=headers, verify=False, timeout=5) if response.status_code == 200 and response.headers.get(&#x27;Content-Type&#x27;) == &#x27;application/octet-stream&#x27;: print(f&quot;可能的 Cobalt Strike 服务器，架构：&#123;arch&#125;，URI：&#123;url&#125;&quot;) # return except requests.RequestException as e: print(f&quot;请求 &#123;url&#125; 时出错：&#123;e&#125;&quot;) print(&quot;未检测到 Cobalt Strike 服务器。&quot;)if __name__ == &quot;__main__&quot;: target_url = &quot;https://192.168.65.170:3344&quot; check_cs_server(target_url) 结果： 特征：发送/aaa9如果HTTP&#x2F;S是Cobalt Strike，会返回Content-Type: application/octet-stream，而且会返回响应体，其中我们可以判断Content-Type: application/octet-stream以及是否存在响应体，以及响应体长度是否大于2000。 0.3 Team Server 连接端口特征一 JARM【弱特征】Team Server用于Cobalt Strike客户端连接到服务器的端口，其中Team Server也使用到了SSL，所有我们可以使用在上文中的JARM去检测。 特征二 TCP流量【强特征】在通过客户端连接到Team Server的时候会产生一系列TLS数据包，其中我们需要使用Wireshark进行抓包解密流量查看特征。 12/usr/lib/jvm/java-11-openjdk-amd64/bin/java -javaagent:jSSLKeyLog.jar=ssss.txt -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -javaagent:CSAgent.jar=CSAgent.properties -Duser.language=en -jar cobaltstrike-client.jarjava -javaagent:&lt;jar包的路径&gt;=&lt;sslkey的存放目录&gt; &lt;正常的jar包路径及参数&gt; jSSLKeyLog 是一个与 Java 应用程序中的 SSL&#x2F;TLS 加密通信相关的工具或机制，主要用于调试和分析 SSL&#x2F;TLS 连接。它的核心作用是记录 SSL&#x2F;TLS 会话的密钥材料（key material），这些密钥材料可以用于解密加密的网络流量。 下载：jSSLKeyLog-1.3.zip java8-11运行 我们需要在客户端开启抓包，同时启动jSSLKeyLog.jar。【此处使用的Cobalt Strike需要是破解版本】 Edit-&gt;Prefernces…-&gt;Protocols-&gt;TLS 导入我们刚刚使用jSSLKeyLog 抓取到的TLS证书密钥。 筛选TCP流量，选择追踪流，追踪TLS 如果抓取密码成功则是下图片，如果失败则为空。 我们可以看到，我们从客户端输入的密码。 当我们输入成功的密码时，原始数据显示： 当我们输入错误密码时，原始数据显示： 而且密码组成是： 1b&#x27;\\x00\\x00\\xbe\\xef\\tadmin123aAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x27; 也就是我们可以通过发送，接收返回值探针是否连接成功：发送请求登录请求数据，判断数据是否是00000000或者是0000cafe。 0.4 总结结合上面两个思路我们可以通过构造特定的数据包去请求Cobalt Strike端口以及特征，需要注意的是这些请求都是有感知的，也就是说在服务端那边是有感知数据的，如下图： 我们可以看到在Web Log以及Team Server存在响应。 JARM 响应头，响应体 checksum8算法 TCP流量 我们可以通过上面四种方式去探针服务器是否部署了Cobalt Strike。 0.5 关于 DarKnuclei关于 DarKnuclei，DarKnuclei专注于红蓝对抗一款工具，不仅可以扫描漏洞，快速打点，还可以扫描红队基础设施与服务，如下图，探针Cobalt Strike端口，判断是否为部署了Cobalt Strike。 html报告","tags":["C2"],"categories":["C2"]},{"title":"测绘语法收集资产","path":"/posts/15280.html","content":"在上一篇关于【关于快速打点思考】中，写到了关于测绘收集资产，这里我们详细的展开讲讲，以FOFA举例，其它的测绘语法大同小异。 FOFA常用搜索语法123456789101112icp=&quot;备案号&quot; # icp=&quot;京ICP证030173号&quot;domain=&quot;域名&quot; # icp=&quot;baidu.com&quot;cert.subject.cn=&quot;证书持有者的通用名称&quot; # cert.subject.cn=&quot;baidu.com&quot;cert.subject.org=&quot;证书持有者的组织&quot; # cert.subject.org=&quot;Beijing Baidu Netcom Science Technology Co., Ltd&quot;title=&quot;beijing&quot; # 网页标题body=&quot;网络空间测绘&quot;\t# 网页正文after=&quot;2024-01-01&quot;\t# 筛选2024-01-01之后有更新的资产before=&quot;2024-12-01&quot;\t# 筛选2024-12-0之前有更新的资产host=&quot;.fofa.com&quot; # 通过主机名进行查询cert=&quot;xxxxx&quot; # 证书序列号查询&amp;&amp; #逻辑与|| #逻辑或 SSL证书SLL是很多人打点的时候忽略掉的一点，为什么SSL证书可以搜索到更加隐蔽的资产？因为网站运维人员在部署SLL证书的时候，对IP地址进行了部署，导致了有些网站访问会出现下面情况，因为SSL证书与域名对不上或者是过期导致，但是我们通过FOFA测绘可以通过证书搜索到绑定证书的资产。 SSL证书我们需要提取一下三点： 证书持有者的通用名称。 证书持有者的组织。 证书序列号。 123cert.subject.cn=&quot;baidu.com&quot; # 证书持有者的通用名称cert.subject.org=&quot;Beijing Baidu Netcom Science Technology Co., Ltd&quot; # 证书持有者的组织cert=&quot;24217219254604001662049442027&quot; # 证书序列号十进制【去冒号查询】 结果： 编写自己的脚本在攻防时候，想要快人一步进行打点，在上一篇文章中【关于快速打点思考】，笔者是将测绘资产进行处理，而读者也可以自行处理，通过FOFA API接口进行操作，下面是搜索集合语句。 常用语法： 查询筛选2024-01-01之后有更新的资产。 1icp=&quot;备案号&quot; || domain=&quot;域名&quot; || cert.subject.cn=&quot;证书持有者的通用名称&quot; || cert.subject.org=&quot;证书持有者的组织&quot; || title=&quot;beijing&quot; || body=&quot;网络空间测绘&quot; || host=&quot;.fofa.com&quot; || cert=&quot;xxxxx&quot; &amp;&amp; after=&quot;2024-01-01&quot; 查询筛选2024-01-01之前有更新的资产 1icp=&quot;备案号&quot; || domain=&quot;域名&quot; || cert.subject.cn=&quot;证书持有者的通用名称&quot; || cert.subject.org=&quot;证书持有者的组织&quot; || title=&quot;beijing&quot; || body=&quot;网络空间测绘&quot; || host=&quot;.fofa.com&quot; || cert=&quot;xxxxx&quot; &amp;&amp; before=&quot;2024-01-01&quot; 注意：关于测绘收录时间年限，每个测绘平台定义不一样，需要读者自行测试。","tags":["资产测绘"],"categories":["信息收集"]},{"title":"关于快速打点思考","path":"/posts/24712.html","content":"项目：RuoJi6&#x2F;DarKnuclei 0.1 思路在前期怎么样对目标进行快速的渗透测试？通过测绘资产快速的进行收集互联网暴露资产，联动指纹识别以及联动扫描工具进行打点。 0.2 难点在攻防或者是渗透测试的时候，组织方给的资产大致分为： 公司名单表 一堆杂乱资产 所以，在编写项目的时候也需要考虑到这两点问题，公司名单列表通过测绘引擎进行处理，一堆杂乱资产通过识别为IP以及WEB进行处理。 0.3 解决0.3.1 测绘语法多角度收集测绘语法如下，同时使用或逻辑进行处理资产。【关于测绘语法，请看下篇文章】 ICP备案号 域名 IP地址 host信息 网站title和body 一年前后数据 SSL证书 公用名 组织 序列号 0.3.2 处理资产在攻防期间，组织方给的目标有可能是： 12345http://baidu.comhttp://baidu.com:1122https://192.168.23.1:8899192.168.23.1baidu.com 进行测试的时候，就需要对资产进行处理，才能进行下一步扫描。 1234567891011121314151617181920212223http://baidu.com http://baidu.com:1122https://192.168.23.175:8899http://baidu.com/asdxasd/asd192.168.23.1conasdasd.com192.168.123.175:1122处理为：http://baidu.com http://baidu.com/asdxasd/asdhttp://baidu.com:1122https://192.168.23.175:8899http://conasdasd.comhttps://conasdasd.comhttps://192.168.124.175:8899http://192.168.123.175:1122https://192.168.123.175:1122192.168.123.175192.168.23.1192.168.124.175 其中，处理分为两部分：WEB，IP。 0.4 扫描处理0.4.1测绘引擎处理得到测绘结果中的IP资产，使用gogo进行资产扫描。 将测绘结果去重，使用observer_ward进行指纹探针，找到对应的指纹使用nuclei使用对应的POC进行扫描。 0.4.2 杂乱资产处理根据杂乱资产：我们可以分成两种情况需要扫描： WEB资产【测绘资产】 IP资产 其中IP需要进行端口扫描，才能进行下一步操作。 资产识别→WEB等待[gogo探测结果] 资产识别→IP→gogo端口探测→收集WEB资产[包括一开始收集的结果]→指纹识别→漏洞扫描 资产识别，分为两种资产，其中IP资产使用gogo自带指纹识别以及漏洞探针进行扫描，将带有WEB的资产和首次识别到的WEB资产进行合并，使用observer_ward进行指纹探针，找到对应的指纹使用nuclei使用对应的POC进行扫描。 0.5 优缺点0.5.1 优点 使用多个测绘语句结合，保证资产结构最大化。 针对杂乱资产，不遗留资产。 0.5.1 缺点需要人进行维护指纹以及POC保证是最新的，需要有一套漏洞运营流程，针对攻防出现的高危POC进行维护更新，这个也是我团队所在做的事情，需要日积月累才能有成效。 0.6 后续思考 针对红队C2服务器进行指纹识别。 C2服务器默认特征，vshell一键上线默认端口探测，以及红队扫描器WEB地址识别，以及yakit，和JNDI注入工具端口识别。 针对防守方蜜罐进行识别。 蜜罐的JS文件，或者是蜜罐的一些特征，又或者是，探测首个发包之后，有没有请求一些敏感域名：qq，baidu等。","tags":["红队"],"categories":["信息收集"]},{"title":"Hello World","path":"/posts/16108.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"about","path":"/about/index.html","content":"弱鸡"}]