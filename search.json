[{"title":"DarKnuclei 工具使用技巧","path":"/posts/33805.html","content":"DarKnuclei是一款适合针对红蓝对抗的一款工具【可跨平台使用】，不仅仅可以在红队视角下的快速打点，还可以在蓝队视角下针对红队基础设施与服务进行探针扫描，DarKnuclei在针对红队基础设施进行扫描针对C2，采用强&#x2F;弱特征，通过C2一些特征值去识别探针，在保证准确率的情况下去尽可能识别多C2，内置yaml语法，使用者可以自己编写yaml文件，识别特定的C2。 0.1 DarKnuclei 入门技巧0.1.1 前置配置在使用DarKnuclei之前要进行一些设置，需要满足以下条件： 如果需要进行漏洞扫描需要将nuclei加入环境变量【同时需要下载nuclei-templates，并在config.ini中配置】。 如需使用测绘功能请修改config.ini添加key。 python版本：python3。 如果是mac或linux请下载对于的执行程序在plugin目录，并配置config.ini。 observer_ward gogo tlsx 配置完以上信息，就可以完美的使用DarKnuclei。 0.1.2 在红队视角下不管是蓝队模块还是会对模块扫描后的结果会保存在project文件中，其中txt为详细信息，html为简略信息。 在上文中，配置完成之后，我们运行python main.py -h可以查看帮助信息； 此时NSM WEB GOGO属于红队模块，RTSCAN属于蓝队模块，接下来我们展开讲讲红队模块： 0.1.2.1 NSM [测绘资产]解决问题：在攻防的时候，拿到手资产，是ip或者是域名又或者是公司怎么样进行快速打点？ 此模块是通过测绘平台进行扫描，前提是需要配置好fofa，以及quake key。 python3 main.py NSM -h查看帮助信息。 案例1在案例1中，我们可以看到输入目标资产的一些信息，查询相关资产【注意如果没有加上-n或-b视为只资产测绘进行查询，而不进行指纹识别以及漏洞扫描】 1python3 main.py NSM -ip xxx.xxx.xxx.xxx -icp 京ICP证030173号 -domain baidu.com -body 百度公司 -title 百度公司管理 在下面两个参数重，根据需求选择，选择之后，将进行相应的模块。 12-b, --observer 指纹扫描-n, --nuclei 指纹+漏洞扫描 【DarKnuclei在设计只初参考了大量的扫描器，DarKnuclei在进行漏洞扫描的时候，均是先指纹识别，通过指纹查询对于的POC，才进行对应的漏洞扫描】 0.1.2.2 WEB [WEB扫描]解决问题：在攻防的时候，拿到一堆资产的时候，怎么样快速打点？ 此模块没有测绘功能，需要用户输入目标，或者是目标集合的文件【如：url.txt】，而且需要注意的是，输入的目标需要是http:&#x2F;&#x2F;或者是https:&#x2F;&#x2F;开头的资产才行，否则会跳过此资产。 0.1.2.3 GOGO [GOGO扫描]解决问题：在攻防的时候，拿到一堆资产的时候，而且资产杂乱，有的是IP，有的是域名，有的带有http，又或者是https，这个时候此工具可以快速的识别并整理资产。【自动识别web资产还有扫描IP信息，识别是http或者是https】 强烈推荐此模块，此模块在针对上一个模块中，针对资产杂乱的问题进行解决，并且，可以定制指定端口扫描。 其中，此工具在使用的时候，必须调用下面两个参数，二选一。 12-b, --observer 指纹扫描-n, --nuclei 指纹+漏洞扫描 0.1.3 在蓝队视角下 【RTSCAN】解决问题：在通过设备捕捉到红队IP的时候，蓝队成员在编写溯源报告的时候，针对红队服务器上开放了什么服务，或者说使用了什么C2进行的攻击，不清楚，此工具不仅仅针对红队平台【ARL…..】，可以针对服务【JNDI…】，还可以针对红队部署的C2【vshell…..】等。 在下图中，列出了目前版本覆盖类型以及指纹。 0.1.3.1 特征覆盖✅\t强特征 ☑️\t弱特征 平台&#x2F;服务 名字 类型 特征 计划中 备注 ARL(灯塔) platform ✅ Scope Sentry platform ✅ NPS platform ✅ AWVS platform ✅ Nessus platform ✅ XSS平台 platform ✅ BeEF platform ✅ H platform ✅ LangSrcCurise platform ✅ Medusa platform ✅ NextScan platform ✅ prismx platform ✅ CyberEdge platform ✅ SerializedPayloadGenerator platform ✅ web-chains platform ✅ RevSuit platform ✅ MemShellParty platform ✅ vulfocus platform ✅ gophish platform ✅ testnet platform ✅ rengine platform ✅ JNDI-Injection-Exploit-Plus Tools ✅ 只针对ldap强特征，rmi,jetty弱特征 JNDI-Injection-Exploit Tools ✅ 只针对ldap强特征，rmi,jetty弱特征 rogue-jndi Tools ✅ 只针对ldap强特征，rmi,jetty弱特征 JNDIMap Tools ✅ 只针对ldap强特征，rmi,jetty弱特征 ysoserial Tools ✔️ C2 名字 版本 登录&#x2F;连接 监听端口 UDP流量 TCP流量 HTTP&#x2F;S流量 计划中 备注 vshell 4.9.3~4.6.0 ✅ ✅ ✅ ✅ Cobalt Strike ✅ ✅ Metasploit ✅ ✅ Supershell 2.0.0 ✅ ✅ Viper ✅ ☑️ ✔️ Daybreak ✔️ chisel ✔️ sliver ✔️ Havoc ✔️ Iom ✔️ Villain ✔️ VenomRA ✔️ ShadowPad ✔️ Shad0w ✔️ Remcos RAT ✔️ QuasarRAT ✔️ Pupy-C2 ✔️ PoshC2 ✔️ PlugX RAT ✔️ Orcus-RAT ✔️ Ninja ✔️ Mythic ✔️ Havoc ✔️ Hak5 Cloud ✔️ Gh0st ✔️ Empire ✔️ DeimosC2 ✔️ DcRAT ✔️ Covenant ✔️ Brute Ratel C4 ✔️ BitRAT ✔️ AsyncRAT ✔️ manjusaka ✔️ 0.1.3.2 使用 python3 main.py RTSCAN -a 此命令可以查看支持的C2的类型，name，以及tags等。 在下面命令中，扫描xxx.xxx.xxxIP中的带有C2 tags的yaml文件。【如果没有指定端口，将会扫描默认常见红队开放端口】 1python3 main.py RTSCAN - i xxx.xxx.xxx -t c2 注意：有些扫描时有感的，所以请配置代理。 效果： 0.1.4 日志&amp;报错在程序运行的时候，不可避免因为代码或者说网络问题出现的错误，日志文件会在log_目录下，以周为单位记录日子，且保留最多3个备份文件，超过的旧文件会被删除。 日志的多个格式: 1234567891011121314152025-01-25 16:11 || INFO || run_def.py || gogo+指纹+漏洞 || /Users/hacker/filename/代码/代码/RT/DarKnuclei_scan/run_def.py 263# 时间 || 级别 || 文件 || 模块 || 文件绝对路径 || 行数# 通常我们只需要关注ERRROR信息，通常在发生ERROR错误的时候，会出现报错原因，且在日志中呀详细的记录，下面是一个错误演示，其中我们可以通过日志进行排查错误。 2025-01-25 16:10 || ERROR || scan.py || An unexpected error occurred: [Errno 2] No such file or directory: &#x27;plugin\\\\gogo_darwin_arm64&#x27; || /Users/hacker/filename/代码/代码/RT/DarKnuclei_scan/scan.py 10082025-01-25 16:10 || ERROR || scan.py || An unexpected error occurred: [Errno 2] No such file or directory: &#x27;plugin\\\\gogo_darwin_arm64&#x27;Traceback (most recent call last): File &quot;/Users/hacker/filename/代码/代码/RT/DarKnuclei_scan/scan.py&quot;, line 866, in scan_gogo_one with subprocess.Popen( File &quot;/Users/jiruo/.pyenv/versions/3.9.21/lib/python3.9/subprocess.py&quot;, line 951, in __init__ self._execute_child(args, executable, preexec_fn, close_fds, File &quot;/Users/jiruo/.pyenv/versions/3.9.21/lib/python3.9/subprocess.py&quot;, line 1837, in _execute_child raise child_exception_type(errno_num, err_msg, err_filename)FileNotFoundError: [Errno 2] No such file or directory: &#x27;plugin\\\\gogo_darwin_arm64&#x27; || /Users/hacker/filename/代码/代码/RT/DarKnuclei_scan/scan.py 1009 0.1.5 扩展红队YAMLDarKnuclei 在红队视角下，用户可自定义YAML文件，针对特定的服务或者C2进行扩展。【待定完成】","tags":["tools"],"categories":["tools"]},{"title":"Cobalt Strike主动识别方案","path":"/posts/58642.html","content":"最近在编写针对红队基础设施扫描的时候，研究针对红队C2识别一些方案特征，这里我们以Cobalt Strike作为特征举例。 0.1 思路众所周知，Cobalt Strike端口可以分为监听端口和Team Server连接端口。 监听端口：Cobalt Strike的Listeners。 连接端口：从客户端连接服务端的端口，由Team Server启动。 由于在攻防中，常见的Cobalt Strike监听端口是HTTP&#x2F;HTTPS，所有这里我们主要去研究HTTP/S和Team Server端口特征方法。 配置【Cobalt Strike 4.7】： 0.2 HTTP&#x2F;S 监听端口特征一 JARM【弱特征】JARM 是一种用于识别和分类 TLS（传输层安全）服务器的指纹识别工具。它通过向目标服务器发送特定构造的 TLS Client Hello 数据包，分析服务器返回的 Server Hello 响应，提取特定属性，生成独特的指纹。这些指纹可用于： 验证服务器组的 TLS 配置一致性：快速检查一组服务器是否具有相同的 TLS 配置。 服务器分组：根据 TLS 配置，将互联网上的服务器进行分组，例如，识别可能属于特定组织（如 Google、Salesforce、Apple）的服务器。 应用程序或基础设施识别：识别默认的应用程序或基础设施。 恶意服务器检测：识别互联网上的恶意软件命令和控制基础设施以及其他恶意服务器。 JARM 的工作原理包括： 发送特定的 TLS Client Hello 数据包：主动向目标 TLS 服务器发送 10 个特定构造的 Client Hello 数据包。 捕获服务器响应：记录服务器返回的 Server Hello 响应，提取其中的特定属性。 生成指纹：对收集的服务器响应进行处理，生成一个 62 字符的指纹，其中前 30 个字符表示服务器对每个 Client Hello 的密码套件和 TLS 版本选择，后 32 个字符是服务器发送的累积扩展名的截断 SHA256 哈希。 projectdiscovery&#x2F;tlsx: Fast and configurable TLS grabber focused on TLS based data collection. 特征：2ad2ad16d2ad2ad00042d42d00042ddb04deffa1705e2edc44cae1ed24a4da，但是由于可以自己生成SSL证书，所有JARM只能算是弱特征。 特征二 响应头【弱特征】默认访问 当我们使用OPTIONS去请求就会出现Allow: OPTIONS,GET,HEAD,POST。 特征：发送OPTIONS得到Allow: OPTIONS,GET,HEAD,POST。 特征三 checksum8算法【强特征】Cobalt Strike 中的 checksum8。在 Cobalt Strike 中，checksum8 是一种用于确定请求 URI 的算法。当用户向 Team Server 发送 HTTP 请求时，服务器会将请求的 URI 传递给 checksum8 函数，并将结果与整数值 92L 或 93L 进行比较。如果结果匹配，服务器将返回相应的 Beacon 二进制负载。具体而言，checksum8 用于区分 32 位和 64 位的 Beacon 负载。 以下是 checksum8函数的 Java 实现： 1234567891011public static long checksum8(String text) &#123; if (text.length() &lt; 4) &#123; return 0L; &#125; text = text.replace(&quot;/&quot;, &quot;&quot;); long sum = 0L; for (int x = 0; x &lt; text.length(); x++) &#123; sum += text.charAt(x); &#125; return sum % 256L;&#125; 也就是说checksum8实现之后的URL是固定的不是随机的，下面我们通过python代码实现这个算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import requestsimport stringfrom itertools import productimport warningswarnings.filterwarnings(&quot;ignore&quot;)def checksum8(uri): &quot;&quot;&quot; 计算 URI 的 checksum8 值。 &quot;&quot;&quot; if len(uri) &lt; 4: return 0 uri = uri.replace(&quot;/&quot;, &quot;&quot;) total = sum(ord(char) for char in uri) return total % 256def generate_uris(): &quot;&quot;&quot; 生成满足 checksum8 为 92（32 位）和 93（64 位）的 URI 列表。 &quot;&quot;&quot; chars = string.ascii_letters + string.digits for combo in product(chars, repeat=4): uri = &#x27;&#x27;.join(combo) cs8 = checksum8(uri) if cs8 == 92: yield uri, &#x27;32-bit&#x27; elif cs8 == 93: yield uri, &#x27;64-bit&#x27;def check_cs_server(base_url): &quot;&quot;&quot; 检查目标服务器是否为 Cobalt Strike 服务器。 &quot;&quot;&quot; headers = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36&#x27; &#125; for uri, arch in generate_uris(): url = f&quot;&#123;base_url&#125;/&#123;uri&#125;&quot; try: response = requests.get(url, headers=headers, verify=False, timeout=5) if response.status_code == 200 and response.headers.get(&#x27;Content-Type&#x27;) == &#x27;application/octet-stream&#x27;: print(f&quot;可能的 Cobalt Strike 服务器，架构：&#123;arch&#125;，URI：&#123;url&#125;&quot;) # return except requests.RequestException as e: print(f&quot;请求 &#123;url&#125; 时出错：&#123;e&#125;&quot;) print(&quot;未检测到 Cobalt Strike 服务器。&quot;)if __name__ == &quot;__main__&quot;: target_url = &quot;https://192.168.65.170:3344&quot; check_cs_server(target_url) 结果： 特征：发送/aaa9如果HTTP&#x2F;S是Cobalt Strike，会返回Content-Type: application/octet-stream，而且会返回响应体，其中我们可以判断Content-Type: application/octet-stream以及是否存在响应体，以及响应体长度是否大于2000。 0.3 Team Server 连接端口特征一 JARM【弱特征】Team Server用于Cobalt Strike客户端连接到服务器的端口，其中Team Server也使用到了SSL，所有我们可以使用在上文中的JARM去检测。 特征二 TCP流量【强特征】在通过客户端连接到Team Server的时候会产生一系列TLS数据包，其中我们需要使用Wireshark进行抓包解密流量查看特征。 12/usr/lib/jvm/java-11-openjdk-amd64/bin/java -javaagent:jSSLKeyLog.jar=ssss.txt -XX:ParallelGCThreads=4 -XX:+AggressiveHeap -XX:+UseParallelGC -javaagent:CSAgent.jar=CSAgent.properties -Duser.language=en -jar cobaltstrike-client.jarjava -javaagent:&lt;jar包的路径&gt;=&lt;sslkey的存放目录&gt; &lt;正常的jar包路径及参数&gt; jSSLKeyLog 是一个与 Java 应用程序中的 SSL&#x2F;TLS 加密通信相关的工具或机制，主要用于调试和分析 SSL&#x2F;TLS 连接。它的核心作用是记录 SSL&#x2F;TLS 会话的密钥材料（key material），这些密钥材料可以用于解密加密的网络流量。 下载：jSSLKeyLog-1.3.zip java8-11运行 我们需要在客户端开启抓包，同时启动jSSLKeyLog.jar。【此处使用的Cobalt Strike需要是破解版本】 Edit-&gt;Prefernces…-&gt;Protocols-&gt;TLS 导入我们刚刚使用jSSLKeyLog 抓取到的TLS证书密钥。 筛选TCP流量，选择追踪流，追踪TLS 如果抓取密码成功则是下图片，如果失败则为空。 我们可以看到，我们从客户端输入的密码。 当我们输入成功的密码时，原始数据显示： 当我们输入错误密码时，原始数据显示： 而且密码组成是： 1b&#x27;\\x00\\x00\\xbe\\xef\\tadmin123aAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x27; 也就是我们可以通过发送，接收返回值探针是否连接成功：发送请求登录请求数据，判断数据是否是00000000或者是0000cafe。 0.4 总结结合上面两个思路我们可以通过构造特定的数据包去请求Cobalt Strike端口以及特征，需要注意的是这些请求都是有感知的，也就是说在服务端那边是有感知数据的，如下图： 我们可以看到在Web Log以及Team Server存在响应。 JARM 响应头，响应体 checksum8算法 TCP流量 我们可以通过上面四种方式去探针服务器是否部署了Cobalt Strike。 0.5 关于 DarKnuclei关于 DarKnuclei，DarKnuclei专注于红蓝对抗一款工具，不仅可以扫描漏洞，快速打点，还可以扫描红队基础设施与服务，拥有高扩展的yaml格式指纹文件，方便自己编写红队基础设施指纹。如下图，探针Cobalt Strike端口，判断是否为部署了Cobalt Strike。 html报告 项目地址RuoJi6&#x2F;DarKnuclei","tags":["C2"],"categories":["C2"]},{"title":"测绘语法收集资产","path":"/posts/15280.html","content":"在上一篇关于【关于快速打点思考】中，写到了关于测绘收集资产，这里我们详细的展开讲讲，以FOFA举例，其它的测绘语法大同小异。 FOFA常用搜索语法123456789101112icp=&quot;备案号&quot; # icp=&quot;京ICP证030173号&quot;domain=&quot;域名&quot; # icp=&quot;baidu.com&quot;cert.subject.cn=&quot;证书持有者的通用名称&quot; # cert.subject.cn=&quot;baidu.com&quot;cert.subject.org=&quot;证书持有者的组织&quot; # cert.subject.org=&quot;Beijing Baidu Netcom Science Technology Co., Ltd&quot;title=&quot;beijing&quot; # 网页标题body=&quot;网络空间测绘&quot;\t# 网页正文after=&quot;2024-01-01&quot;\t# 筛选2024-01-01之后有更新的资产before=&quot;2024-12-01&quot;\t# 筛选2024-12-0之前有更新的资产host=&quot;.fofa.com&quot; # 通过主机名进行查询cert=&quot;xxxxx&quot; # 证书序列号查询&amp;&amp; #逻辑与|| #逻辑或 SSL证书SLL是很多人打点的时候忽略掉的一点，为什么SSL证书可以搜索到更加隐蔽的资产？因为网站运维人员在部署SLL证书的时候，对IP地址进行了部署，导致了有些网站访问会出现下面情况，因为SSL证书与域名对不上或者是过期导致，但是我们通过FOFA测绘可以通过证书搜索到绑定证书的资产。 SSL证书我们需要提取一下三点： 证书持有者的通用名称。 证书持有者的组织。 证书序列号。 123cert.subject.cn=&quot;baidu.com&quot; # 证书持有者的通用名称cert.subject.org=&quot;Beijing Baidu Netcom Science Technology Co., Ltd&quot; # 证书持有者的组织cert=&quot;24217219254604001662049442027&quot; # 证书序列号十进制【去冒号查询】 结果： 编写自己的脚本在攻防时候，想要快人一步进行打点，在上一篇文章中【关于快速打点思考】，笔者是将测绘资产进行处理，而读者也可以自行处理，通过FOFA API接口进行操作，下面是搜索集合语句。 常用语法： 查询筛选2024-01-01之后有更新的资产。 1icp=&quot;备案号&quot; || domain=&quot;域名&quot; || cert.subject.cn=&quot;证书持有者的通用名称&quot; || cert.subject.org=&quot;证书持有者的组织&quot; || title=&quot;beijing&quot; || body=&quot;网络空间测绘&quot; || host=&quot;.fofa.com&quot; || cert=&quot;xxxxx&quot; &amp;&amp; after=&quot;2024-01-01&quot; 查询筛选2024-01-01之前有更新的资产 1icp=&quot;备案号&quot; || domain=&quot;域名&quot; || cert.subject.cn=&quot;证书持有者的通用名称&quot; || cert.subject.org=&quot;证书持有者的组织&quot; || title=&quot;beijing&quot; || body=&quot;网络空间测绘&quot; || host=&quot;.fofa.com&quot; || cert=&quot;xxxxx&quot; &amp;&amp; before=&quot;2024-01-01&quot; 注意：关于测绘收录时间年限，每个测绘平台定义不一样，需要读者自行测试。","tags":["资产测绘"],"categories":["信息收集"]},{"title":"关于快速打点思考","path":"/posts/24712.html","content":"项目：RuoJi6&#x2F;DarKnuclei 0.1 思路在前期怎么样对目标进行快速的渗透测试？通过测绘资产快速的进行收集互联网暴露资产，联动指纹识别以及联动扫描工具进行打点。 0.2 难点在攻防或者是渗透测试的时候，组织方给的资产大致分为： 公司名单表 一堆杂乱资产 所以，在编写项目的时候也需要考虑到这两点问题，公司名单列表通过测绘引擎进行处理，一堆杂乱资产通过识别为IP以及WEB进行处理。 0.3 解决0.3.1 测绘语法多角度收集测绘语法如下，同时使用或逻辑进行处理资产。【关于测绘语法，请看下篇文章】 ICP备案号 域名 IP地址 host信息 网站title和body 一年前后数据 SSL证书 公用名 组织 序列号 0.3.2 处理资产在攻防期间，组织方给的目标有可能是： 12345http://baidu.comhttp://baidu.com:1122https://192.168.23.1:8899192.168.23.1baidu.com 进行测试的时候，就需要对资产进行处理，才能进行下一步扫描。 1234567891011121314151617181920212223http://baidu.com http://baidu.com:1122https://192.168.23.175:8899http://baidu.com/asdxasd/asd192.168.23.1conasdasd.com192.168.123.175:1122处理为：http://baidu.com http://baidu.com/asdxasd/asdhttp://baidu.com:1122https://192.168.23.175:8899http://conasdasd.comhttps://conasdasd.comhttps://192.168.124.175:8899http://192.168.123.175:1122https://192.168.123.175:1122192.168.123.175192.168.23.1192.168.124.175 其中，处理分为两部分：WEB，IP。 0.4 扫描处理0.4.1测绘引擎处理得到测绘结果中的IP资产，使用gogo进行资产扫描。 将测绘结果去重，使用observer_ward进行指纹探针，找到对应的指纹使用nuclei使用对应的POC进行扫描。 0.4.2 杂乱资产处理根据杂乱资产：我们可以分成两种情况需要扫描： WEB资产【测绘资产】 IP资产 其中IP需要进行端口扫描，才能进行下一步操作。 资产识别→WEB等待[gogo探测结果] 资产识别→IP→gogo端口探测→收集WEB资产[包括一开始收集的结果]→指纹识别→漏洞扫描 资产识别，分为两种资产，其中IP资产使用gogo自带指纹识别以及漏洞探针进行扫描，将带有WEB的资产和首次识别到的WEB资产进行合并，使用observer_ward进行指纹探针，找到对应的指纹使用nuclei使用对应的POC进行扫描。 0.5 优缺点0.5.1 优点 使用多个测绘语句结合，保证资产结构最大化。 针对杂乱资产，不遗留资产。 0.5.1 缺点需要人进行维护指纹以及POC保证是最新的，需要有一套漏洞运营流程，针对攻防出现的高危POC进行维护更新，这个也是我团队所在做的事情，需要日积月累才能有成效。 0.6 后续思考 针对红队C2服务器进行指纹识别。 C2服务器默认特征，vshell一键上线默认端口探测，以及红队扫描器WEB地址识别，以及yakit，和JNDI注入工具端口识别。 针对防守方蜜罐进行识别。 蜜罐的JS文件，或者是蜜罐的一些特征，又或者是，探测首个发包之后，有没有请求一些敏感域名：qq，baidu等。","tags":["红队"],"categories":["信息收集"]},{"title":"Hello World","path":"/posts/16108.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"about","path":"/about/index.html","content":"弱鸡Admin"}]